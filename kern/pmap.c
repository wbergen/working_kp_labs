/* See COPYRIGHT for copyright information. */

#include <inc/x86.h>
#include <inc/mmu.h>
#include <inc/error.h>
#include <inc/string.h>
#include <inc/assert.h>

#include <kern/pmap.h>
#include <kern/kclock.h>


/* These variables are set by i386_detect_memory() */
pde_t *kern_pgdir;              /* Kernel's initial page directory */
size_t npages;                  /* Amount of physical memory (in pages) */
size_t PREMAPPED_FLAG;
static size_t npages_basemem;   /* Amount of base memory (in pages) */

/* These variables are set in mem_init() */
struct page_info *pages;                 /* Physical page state array */
static struct page_info *page_free_list; /* Free list of physical pages */



/***************************************************************
 * Detect machine's physical memory setup.
 ***************************************************************/

static int nvram_read(int r)
{
    return mc146818_read(r) | (mc146818_read(r + 1) << 8);
}

static void i386_detect_memory(void)
{
    size_t npages_extmem;

    /* Use CMOS calls to measure available base & extended memory.
     * (CMOS calls return results in kilobytes.) */
    npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
    npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;

    /* Calculate the number of physical pages available in both base and
     * extended memory. */
    if (npages_extmem)
        npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
    else
        npages = npages_basemem;

    cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
        npages * PGSIZE / 1024,
        npages_basemem * PGSIZE / 1024,
        npages_extmem * PGSIZE / 1024);
}


/***************************************************************
 * Set up memory mappings above UTOP.
 ***************************************************************/
static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size,
        physaddr_t pa, int perm);
static void check_page_free_list(bool only_low_memory);
static void check_page_alloc(void);
static void check_kern_pgdir(void);
static physaddr_t check_va2pa(pde_t *pgdir, uintptr_t va);
static void check_page(void);
static void check_page_installed_pgdir(void);
static void check_page_hugepages(void);

/* This simple physical memory allocator is used only while JOS is setting up
 * its virtual memory system.  page_alloc() is the real allocator.
 *
 * If n>0, allocates enough pages of contiguous physical memory to hold 'n'
 * bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
 *
 * If n==0, returns the address of the next free page without allocating
 * anything.
 *
 * If we're out of memory, boot_alloc should panic.
 * This function may ONLY be used during initialization, before the
 * page_free_list list has been set up. */
static void *boot_alloc(uint32_t n)
{
    static char *nextfree;  /* virtual address of next byte of free memory */
    char *result;
    int pages_to_alloc;

    /* Initialize nextfree if this is the first time. 'end' is a magic symbol
     * automatically generated by the linker, which points to the end of the
     * kernel's bss segment: the first virtual address that the linker did *not*
     * assign to any kernel code or global variables. */
    if (!nextfree) {
        extern char end[];
        nextfree = ROUNDUP((char *) end, PGSIZE);
    }

    /* Allocate a chunk large enough to hold 'n' bytes, then update nextfree.
     * Make sure nextfree is kept aligned to a multiple of PGSIZE.
     *
     * LAB 1: Your code here.
     */

    // CASE: n == 0:
    if (n == 0){
        return nextfree;
    // CASE n > 0:
    } else if (n > 0){      
        // Allocate chunk page aligned
        if (PGSIZE % n != 0){
            pages_to_alloc = n / PGSIZE + 1;
        } else {
            pages_to_alloc = n / PGSIZE;
        }
        // Increment nextfree to the next available page
        result = nextfree;
        nextfree += PGSIZE * pages_to_alloc;

        // Out of Memory check
        if((unsigned int)nextfree > npages * PGSIZE + KERNBASE){
            panic("BOOT ALLOCATOR: OUT OF MEMORY BITCH\n");
        }

        return result;
    }
    // CASE else:
    return NULL;
}

/*
 * Set up a two-level page table:
 *    kern_pgdir is its linear (virtual) address of the root
 *
 * This function only sets up the kernel part of the address space (ie.
 * addresses >= UTOP).  The user part of the address space will be setup later.
 *
 * From UTOP to ULIM, the user is allowed to read but not write.
 * Above ULIM the user cannot read or write.
 */
void mem_init(void)
{
    uint32_t cr0;
    size_t n;

    /* Find out how much memory the machine has (npages & npages_basemem). */
    i386_detect_memory();
    PREMAPPED_FLAG = 1;
    /*********************************************************************
     * create initial page directory.
     */
    kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
    memset(kern_pgdir, 0, PGSIZE);

    /*********************************************************************
     * Recursively insert PD in itself as a page table, to form a virtual page
     * table at virtual address UVPT.
     * (For now, you don't have understand the greater purpose of the following
     * line.)
     */

    /* Permissions: kernel R, user R */
    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    /*********************************************************************
     * Allocate an array of npages 'struct page_info's and store it in 'pages'.
     * The kernel uses this array to keep track of physical pages: for each
     * physical page, there is a corresponding struct page_info in this array.
     * 'npages' is the number of physical pages in memory.  Your code goes here.
     */
    // Allocate enough memory to contain the pages list
    pages = boot_alloc((npages)*sizeof(struct page_info));

    /*********************************************************************
     * Now that we've allocated the initial kernel data structures, we set
     * up the list of free physical pages. Once we've done so, all further
     * memory management will go through the page_* functions. In particular, we
     * can now map memory using boot_map_region or page_insert.
     */
    page_init();

    check_page_free_list(1);
    check_page_alloc();

    check_page();

/*********************************************************************
     * Now we set up virtual memory */

/*********************************************************************
     * Map 'pages' read-only by the user at linear address UPAGES
     * Permissions:
     *    - the new image at UPAGES -- kernel R, user R
     *      (ie. perm = PTE_U | PTE_P)
     *    - pages itself -- kernel RW, user NONE
     * Your code goes here:
     */

    //boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
    // cprintf("UPAGES: %u, PTSIZE: %u\n", UPAGES, PTSIZE);
    // I think correct:
    boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U );

/*********************************************************************
     * Use the physical memory that 'bootstack' refers to as the kernel
     * stack.  The kernel stack grows down from virtual address KSTACKTOP.
     * We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
     * to be the kernel stack, but break this into two pieces:
     *     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
     *     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
     *       the kernel overflows its stack, it will fault rather than
     *       overwrite memory.  Known as a "guard page".
     *     Permissions: kernel RW, user NONE
     * Your code goes here:
     */
    //boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm);

    // [KSTACKTOP-KSTKSIZE, KSTACKTOP)

    // cprintf("stack_size: %u\n", stack_size);
    // I think correct (BUT) maybe it should be all done in one, not two calls...
    boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);

    /* Note: Dont map anything between KSTACKTOP - PTSIZE and KSTACKTOP - KTSIZE
     * leaving this as guard region.
     */

/*********************************************************************
     * Map all of physical memory at KERNBASE.
     * Ie.  the VA range [KERNBASE, 2^32) should map to
     *      the PA range [0, 2^32 - KERNBASE)
     * We might not have 2^32 - KERNBASE bytes of physical memory, but
     * we just set up the mapping anyway.
     * Permissions: kernel RW, user NONE
     * Your code goes here:
     */

    // t should be one 2^32-KERNBASE
    // Should be correct...
    uint32_t t = 0 - KERNBASE;
    // cprintf("t: %u == 4294967296. ROUNDUP: %u\n", t, ROUNDUP(t, PGSIZE));
    boot_map_region(kern_pgdir, KERNBASE, t, 0, PTE_W);

    /* Enable Page Size Extensions for huge page support */
    lcr4(rcr4() | CR4_PSE);

    /* Check that the initial page directory has been set up correctly. */
    check_kern_pgdir();

    /* Switch from the minimal entry page directory to the full kern_pgdir
    / * page table we just created.  Our instruction pointer should be
     * somewhere between KERNBASE and KERNBASE+4MB right now, which is
     * mapped the same way by both page tables.
     *
     * If the machine reboots at this point, you've probably set up your
     * kern_pgdir wrong. */
    lcr3(PADDR(kern_pgdir));

    check_page_free_list(0);

    /* entry.S set the really important flags in cr0 (including enabling
     * paging).  Here we configure the rest of the flags that we care about. */
    cr0 = rcr0();
    cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
    cr0 &= ~(CR0_TS|CR0_EM);
    lcr0(cr0);
    PREMAPPED_FLAG = 0;
    /* Some more checks, only possible after kern_pgdir is installed. */
    check_page_installed_pgdir();

    /* Check for huge page support */
    check_page_hugepages();
}

int is_allocated_init(struct page_info *pp){
    physaddr_t page_a;
    page_a = page2pa(pp);

    if(page_a < npages_basemem * PGSIZE){
        return 0;
    }
    if(page_a >= IOPHYSMEM && page_a < EXTPHYSMEM){
        return 1;
    }
    if(page_a >= EXTPHYSMEM && page_a < PADDR(boot_alloc(0))){
        return 1;
    }
    return 0;
}

/*
    This function removes an element from the had of the page free list 
    It doesn't modify any flags
*/
struct page_info * remove_head_pfl(){

    struct page_info * pp = page_free_list;

    page_free_list = pp->pp_link;
    pp->pp_link = NULL;

    return pp;
}

/*
    This function removes an precise element from the page free list
    It doesn't modify any flags
*/
void remove_element_pfl(struct page_info * pp){

    struct page_info * pp_c = page_free_list;
    struct page_info * pp_old;

    if(page_free_list == pp){
        page_free_list = pp->pp_link;
        pp->pp_link = NULL;
        return; 
    }
    while(pp_c){
        if(pp_c == pp){
            pp_old->pp_link = pp_c->pp_link;
            pp->pp_link = NULL;
            return;
        }
        pp_old = pp_c;
        pp_c = pp_c->pp_link;
    }
}

/*
    Returns a page with a PA in the first 4MB
    To use when only the first 4 MB of PA are mapped
*/
struct page_info * remove_element_4MB_pfl(){

    struct page_info * pp = page_free_list;
    struct page_info * pp_old = NULL;

    if(page2pa(page_free_list) < 0x400000){
        page_free_list = pp->pp_link;
        pp->pp_link = NULL;
        return pp; 
    }
    while(pp){
        if(page2pa(pp) < 0x400000){
            pp_old->pp_link = pp->pp_link;
            pp->pp_link = NULL;
            return pp;
        }
        pp_old = pp;
        pp = pp->pp_link;
    }
    return NULL;
}

/*
    This function adds an element from the had of the page free list
    It doesn't modify any flags
*/
void add_head_pfl(struct page_info * pp){

    pp->pp_link = page_free_list;
    page_free_list = pp;

}

/***************************************************************
 * Tracking of physical pages.
 * The 'pages' array has one 'struct page_info' entry per physical page.
 * Pages are reference counted, and free pages are kept on a linked list.
 ***************************************************************/

/*
 * Initialize page structure and memory free list.
 * After this is done, NEVER use boot_alloc again.  ONLY use the page
 * allocator functions below to allocate and deallocate physical
 * memory via the page_free_list.
 */
void page_init(void)
{
 /*
     * The example code here marks all physical pages as free.
     * However this is not truly the case.  What memory is free?
     *  1) Mark physical page 0 as in use.
     *     This way we preserve the real-mode IDT and BIOS structures in case we
     *     ever need them.  (Currently we don't, but...)
     *  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE) is free.
     *  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must never be
     *     allocated.
     *  4) Then extended memory [EXTPHYSMEM, ...).
     *     Some of it is in use, some is free. Where is the kernel in physical
     *     memory?  Which pages are already in use for page tables and other
     *     data structures?
     *
     * Change the code to reflect this.
     * NB: DO NOT actually touch the physical memory corresponding to free
     *     pages! */
    size_t i;

    // Page 0 not in use, it won't be added to the free list   
    pages[0].pp_ref = 0;
    pages[0].pp_link = NULL;
    pages[0].page_flags = 0;

    for (i = 1; i < npages; i++) {

        //initialize the page_info fields
        pages[i].pp_ref = 0;
        pages[i].pp_link = NULL;
        pages[i].page_flags = 0;
        if( !is_allocated_init(&pages[i])){
            add_head_pfl(&pages[i]);
        }else{
            pages[i].page_flags |= ALLOC;
        }
    }
}

/*
 * Allocates a physical page.  
 * If (alloc_flags & ALLOC_ZERO), fills the entire
 * returned physical page with '\0' bytes.  Does NOT increment the reference
 * count of the page - the caller must do these if necessary (either explicitly
 * or via page_insert).
 * If (alloc_flags & ALLOC_PREMAPPED), returns a physical page from the 
 * initial pool of mapped pages.
 * 
 * Be sure to set the pp_link field of the allocated page to NULL so
 * page_free can check for double-free bugs.
 *
 * Returns NULL if out of free memory.
 *
 * Hint: use page2kva and memset
 * 
 * 4MB huge pages:
 * Come back later to extend this function to support 4MB huge page allocation.
 * If (alloc_flags & ALLOC_HUGE), returns a huge physical page of 4MB size.
 */
struct page_info *page_alloc(int alloc_flags)
{
    struct page_info * pg0;

    // Out of pages
    if( !page_free_list ){
        return NULL;
    }
    //Huge page non consecutive support     /*  STILL TO TEST */
    if(alloc_flags & ALLOC_HUGE_NC){

        int count = 0;
        int first_hp;
        struct page_info * pp = page_free_list;
        struct page_info * pp_old, *pp_ret, * pp_sup;

        //look for available nc huge pages
        while(pp || count != KB){
            count++;
            pp_old = pp;
            pp = pp->pp_link;
        }
         if(count == KB){
            /* GIVE HUGE PAGE*/
            pp_ret = page_free_list;
            page_free_list = pp;
            pp_old->pp_link = NULL;

            // Set the ALLOC flag
            pp_sup = pp_ret;
            while(pp_sup){
                if((pp_sup->page_flags & ALLOC) || (pp_sup->page_flags & ALLOC_HUGE) || (pp_sup->page_flags & ALLOC_HUGE_NC)){
                    panic("page_alloc huge: PAGE TO ALLOC ALREADY MARKED ALLOC\n");
               }
                if(alloc_flags & POISON_AFTER_FREE){
                    if(pp_sup->page_flags & POISON_AFTER_FREE){
                        panic("page_alloc huge: PAGE TO ALLOC ALREADY MARKED AS POISON_AFTER_FREE\n");
                    }
                    pp_sup->page_flags |= POISON_AFTER_FREE;
                }
                if((alloc_flags & ALLOC_ZERO)){
                    memset( page2kva(pp_sup) ,'\0', PGSIZE );
                }
                pp_sup->page_flags |= ALLOC;
                pp_sup = pp_sup->pp_link;
            }
            // Set the ALLOC_HUGE_NC flag
            pp_ret->page_flags |= ALLOC_HUGE_NC;
            return pp_ret;
        } 
        /*HUGE PAGE NOT AVAILABLE*/
        return NULL;
    }
    //Huge page consecutive support
    if(alloc_flags & ALLOC_HUGE){

        int count = 0; // Free consecutive pages count
        int hp_idx = 0; // to keep track of a valid Huge Page candidate
        int i,j; // j = 4MB iterator i = page iterator

        // Checks if there are 1024 consecutive and aligned free pages
        for(j=0; j<(npages/KB); j++){
            hp_idx = j*KB;
            for(i = 0; i < KB; i++){
                if(!(pages[i+hp_idx].page_flags & ALLOC)){
                    count++;
                }else{
                    count = 0;
                    break;
                }
            }
            if(count == KB){
                break;
            }
            
        }
        if(count == KB){
            if(alloc_flags & POISON_AFTER_FREE){
                if(pages[hp_idx].page_flags & POISON_AFTER_FREE){
                    panic("page_alloc huge: PAGE TO ALLOC ALREADY MARKED AS POISON_AFTER_FREE\n");
                }
                pages[hp_idx].page_flags |= POISON_AFTER_FREE;
            }
            if(pages[hp_idx].page_flags & ALLOC_HUGE){
                panic("page_alloc huge: PAGE TO ALLOC ALREADY MARKED ALLOC\n");
            }
            pages[hp_idx].page_flags |= ALLOC_HUGE;

            for(i = hp_idx; i < (hp_idx + KB); i++){
                if(alloc_flags & POISON_AFTER_FREE){
                    if(pages[i].page_flags & POISON_AFTER_FREE){
                        panic("page_alloc huge: PAGE TO ALLOC ALREADY MARKED AS POISON_AFTER_FREE\n");
                    }
                    pages[i].page_flags |= POISON_AFTER_FREE;
                }
                if((i != hp_idx) && (pages[i].page_flags & ALLOC_HUGE)){
                    panic("page_alloc huge: PAGE TO ALLOC ALREADY MARKED ALLOC\n");
                }
                if((pages[i].page_flags & ALLOC) || (pages[i].page_flags & ALLOC_HUGE_NC)){
                    panic("page_alloc huge: PAGE TO ALLOC ALREADY MARKED ALLOC\n");
               }
                if((alloc_flags & ALLOC_ZERO)){
                    memset( page2kva(&pages[i]) ,'\0', PGSIZE );
               }
                pages[i].page_flags |= ALLOC;
                remove_element_pfl(&pages[i]);
            }
            return &pages[hp_idx];
        }else{
            return NULL;
        }
    }
    // Single page allocation
    if(PREMAPPED_FLAG){
        pg0 = remove_element_4MB_pfl();
    }else{
        pg0 = remove_head_pfl();
    }
    

    if((pg0->page_flags & ALLOC) || (pg0->page_flags & ALLOC_HUGE) || (pg0->page_flags & ALLOC_HUGE_NC)){
        panic("page_alloc: PAGE TO ALLOC ALREADY MARKED ALLOC\n");
    }
    if(alloc_flags & POISON_AFTER_FREE){
        if(pg0->page_flags & POISON_AFTER_FREE){
            panic("page_alloc huge: PAGE TO ALLOC ALREADY MARKED AS POISON_AFTER_FREE\n");
        }
        pg0->page_flags |= POISON_AFTER_FREE;
    }
    // Set the Alloc flag
    pg0->page_flags |= ALLOC;

    // ALLOC_ZERO support

    if((alloc_flags & ALLOC_ZERO) ){
        memset( page2kva(pg0) ,'\0', PGSIZE );          
    }
    return pg0;
}

void poison_page(struct page_info * pp){
    memset(page2kva(pp), 1, PGSIZE);
}


/*
 * Return a page to the free list.
 * (This function should only be called when pp->pp_ref reaches 0.)
 */
void page_free(struct page_info *pp)
{

    /* Fill this function in
     * Hint: You may want to panic if pp->pp_ref is nonzero or
     * pp->pp_link is not NULL. */
    struct page_info * pp_sup, * pp_old;
    int count = 0;

    //Panic in case of pp_ref is not 0 or if pp_link is not NULL
    if(pp->pp_ref){
        panic(" page_free: THE PAGE TO FREE IS STILL REFERENCED\n");
    }
    if(pp->pp_link && (pp->page_flags & ALLOC_HUGE_NC)){
        panic(" page_free: THE PAGE TO FREE IS LINKED TO A FREE ELEMENT\n");
    }
    /*  Not consecutive Huge Page free */
    if(pp->page_flags & ALLOC_HUGE_NC){
        pp_sup = pp;
        while(pp_sup){
            count++;
            pp_old = pp_sup;
            pp_sup = pp_sup->pp_link;
        }
        if(count != KB){
            panic("page_free: THIS IS NOT A HUGE PAGE!\n");
        }

        //ALLOC_HUGE_NC flag reset
        pp->page_flags = pp->page_flags ^ ALLOC_HUGE_NC;

        //ALLOC flag reset
        pp_sup = pp; 
        while(pp_sup){
            if(!(pp_sup->page_flags & ALLOC)){
                panic("page free: THE ALLOC FLAG IS NOT SET\n");
            }
            if(pp_sup->page_flags & POISON_AFTER_FREE){
                poison_page(pp_sup);
                pp_sup->page_flags = pp_sup->page_flags ^ POISON_AFTER_FREE;
            }
            pp_sup->page_flags = pp_sup->page_flags ^ ALLOC;
            pp_sup = pp_sup->pp_link;
        }
        //Meging huge page list with free page list
        pp_old->pp_link = page_free_list;
        page_free_list = pp;
        return;
    }

    /* Huge page free */
    if(pp->page_flags & ALLOC_HUGE){
        int i;
        uint32_t idx = PGNUM(page2pa(pp));

        //Check for errors
        for(i = idx; i < (idx + KB); i++){
            if(!(pages[i].page_flags & ALLOC)){
                panic("page_free huge: PAGE TO FREE NOT MARKED ALLOC \n");
            }
            if(pages[i].pp_ref){
                panic(" page_free huge: THE PAGE TO FREE IS STILL REFERENCED\n");
            }
            if(pages[i].pp_link){
                panic(" page_free huge: THE PAGE TO FREE IS LINKED TO A FREE ELEMENT\n");
            }
        }

        //Reset the ALLOC_HUGE flag
        pages[idx].page_flags = pages[idx].page_flags ^ ALLOC_HUGE;

        //Reset the ALLOC flags and add the page to the page_free_list
        for(i = idx; i < (idx + KB); i++){
            if(pages[i].page_flags & POISON_AFTER_FREE){
                poison_page(&pages[i]);
                pages[i].page_flags = pages[i].page_flags ^ POISON_AFTER_FREE;
            }
            pages[i].page_flags = pages[i].page_flags ^ ALLOC;
            add_head_pfl(&pages[i]);
        }
        return;
    }

    // ALLOC flag reset
    if(pp->page_flags & POISON_AFTER_FREE){
        poison_page(pp);
        pp->page_flags = pp->page_flags ^ POISON_AFTER_FREE;
    }
    if(pp->page_flags & ALLOC){
        pp->page_flags = pp->page_flags ^ ALLOC;
    }else{
        panic("page free: PAGE TO FREE MARKED AS NOT ALLOC\n");
    }
    
    add_head_pfl(pp);
}

/*
 * Decrement the reference count on a page,
 * freeing it if there are no more refs.
 */
void page_decref(struct page_info* pp)
{
    if (--pp->pp_ref == 0)
        page_free(pp);
}

void panic_if_null(char * message, void* ptr){
    if(!ptr){
        panic(message);
    }
}
/*
 * Given 'pgdir', a pointer to a page directory, pgdir_walk returns
 * a pointer to the page table entry (PTE) for linear address 'va'.
 * This requires walking the two-level page table structure.
 *
 * For normal 4K paging support:
 *  The relevant page table page might not exist yet.
 *  If this is true, and create == 0, then pgdir_walk returns NULL.
 *  Otherwise, if CREATE_NORMAL flag is set in the 'create' argument,
 *  pgdir_walk allocates a new page table page with page_alloc.
 *    - If the allocation fails, pgdir_walk returns NULL.
 *    - Otherwise, the new page's reference count is incremented,
 *      the page is cleared,
 *      and pgdir_walk returns a pointer into the new page table page.
 *
 * For huge 4MB paging support:
 *  Is two-level walk required in this case?
 *  If the relevant page table entry does not exist and create == false,
 *  then, pgdir_walk returns NULL.
 *  Otherwise, if CREATE_HUGE flag is set in the 'create' argument,
 *  pgdir_walk() returns a pointer to page table entry for the huge page.

 * Hint 1: you can turn a struct page_info* into the physical address of the
 * page it refers to with page2pa() from kern/pmap.h.
 *
 * Hint 2: the x86 MMU checks permission bits in both the page directory
 * and the page table, so it's safe to leave permissions in the page
 * more permissive than strictly necessary.
 *
 * Hint 3: look at inc/mmu.h for useful macros that manipulate page
 * table and page directory entries.
 */
pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create){
    // Panic if the pagetable directory is null
    panic_if_null("pgdir_walk: PAGE TABLE DIRECTORY NULL\n", (void *)pgdir);

    // Page table directory entry index
    int ptd_idx = PDX(va);
    int pte_idx = PTX(va);

    // Page to allocate in case the pte is not present
    struct page_info * pg;

    // Page table entry to return and page table to adress
    pte_t * pte;

    // Page table Directory entry
    pde_t ptd_entry = pgdir[ptd_idx];

    // Create a huge page
    if(!(ptd_entry & PTE_P)){
        // If create is 0 return null
        if(create == 0){
            return NULL;
        }
        if(create & CREATE_HUGE){

            pgdir[ptd_idx] = 0;

            ptd_entry = pgdir[ptd_idx];

        }
        // If CREATE_NORMAL is set first allocate a page for the PT and then set it whithin the PTD entry
        if(create & CREATE_NORMAL){
            // Allocate the page with ALLOC_ZERO to initialize it and POISON_AFTER_FREE
            pg = page_alloc( ALLOC_ZERO );             
            // If the allocation fails return NULL
            if(!pg){
                return NULL;
            }
            // Set the page in pgdir with present, write and user flags set
            pgdir[ptd_idx] = page2pa(pg) | PTE_P | PTE_W | PTE_U;
            // Increment the reference count
            pg->pp_ref += 1;

            ptd_entry = pgdir[ptd_idx];

        }
    }
    // If it's a huge page return the entry from PTD otherwise look up the PTE 
    if(ptd_entry & PTE_PS){
        //return the pointer to the huge page
        return &pgdir[ptd_idx];
    }else{
        // Find the K virtual address of the pte_entry
        pte = KADDR(PTE_ADDR(ptd_entry));
        return &pte[pte_idx];
    }

}

/*
 * Map [va, va+size) of virtual address space to physical [pa, pa+size)
 * in the page table rooted at pgdir.  Size is a multiple of PGSIZE.
 * Use permission bits perm|PTE_P for the entries.
 *
 * This function is only intended to set up the ``static'' mappings
 * above UTOP. As such, it should *not* change the pp_ref field on the
 * mapped pages.
 *
 * Hint: the TA solution uses pgdir_walk
 */
static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
    /* Fill this function in */

    panic_if_null("boot_map_region: pgdir is NULL!\n", pgdir);

    /*
    - size is a multiple of page size.  so basically we wanna map
     size/PGSIZE pages.
    - each round:
        - create single mapping like above:
        - increment va and pa by 1 PGSIZE
        - decrement pages_to_map
    */

    // Ensure size is actually a multiple of PGSIZE
    if (size % PGSIZE != 0){
        panic("boot_map_region: size is not a multiple of PGSIZE!\n");
    }

    // Number of pages to map:
    int pages_to_map = size/PGSIZE;


    // Map Pages:
    for (int i = 0; i < pages_to_map; ++i)
    {
        // Get a new page:
        pte_t * pte = pgdir_walk(pgdir, (void *)va, CREATE_NORMAL);

        // Check and set the pa's flags:
        if (perm & PTE_P){
            panic("boot_map_region: PTE_P already set in perms!\n");
        }

        pa |= perm | PTE_P;

        // Set va -> pa:
        *pte = pa;

        // Inc va, pa and dec. size:
        va += PGSIZE;
        pa += PGSIZE;
    }


}

/*
 * Map the physical page 'pp' at virtual address 'va'.
 * The permissions (the low 12 bits) of the page table entry
 * should be set to 'perm|PTE_P'.
 *
 * Requirements
 *   - If there is already a page mapped at 'va', it should be page_remove()d.
 *   - If necessary, on demand, a page table should be allocated and inserted
 *     into 'pgdir'.
 *   - pp->pp_ref should be incremented if the insertion succeeds.
 *   - The TLB must be invalidated if a page was formerly present at 'va'.
 *
 * Corner-case hint: Make sure to consider what happens when the same
 * pp is re-inserted at the same virtual address in the same pgdir.
 * However, try not to distinguish this case in your code, as this
 * frequently leads to subtle bugs; there's an elegant way to handle
 * everything in one code path.
 *
 * RETURNS:
 *   0 on success
 *   -E_NO_MEM, if page table couldn't be allocated
 *
 * Hint: The TA solution is implemented using pgdir_walk, page_remove,
 * and page2pa.
 *
 * Also add support for huge page insertion.
 */
int page_insert(pde_t *pgdir, struct page_info *pp, void *va, int perm)
{

    panic_if_null("pgdir_walk: PAGE TABLE DIRECTORY NULL\n", (void *)pgdir);
    panic_if_null("pgdir_walk: PAGE_INFO IS NULL\n", (void *)pp);

    // Check and set the pa's flags:
    if (perm & PTE_P){
        panic("page_insert: PTE_P already set in perms!\n");
    }

    pte_t * pte;
    int re_ins_flag;
    
    // Find the PTE (allocate huge or normal in case it's not)
    if(perm & PTE_PS){
        pte = pgdir_walk(pgdir, va, CREATE_HUGE);
    }else{
        pte = pgdir_walk(pgdir, va, CREATE_NORMAL);
    }

    // No memory return
    if(!pte){
        return -E_NO_MEM;
    }

    // Check for re insertion of the same page
    re_ins_flag = (PTE_ADDR(*pte) !=  page2pa(pp));

    // If the page is present, remove it
    if((*pte & PTE_P) && re_ins_flag ){
        page_remove(pgdir, va);
    }
 
    // Increment the ref count
    if(re_ins_flag){
        pp->pp_ref++;
    }

    // Insert the page with the perm flags and PTE_P
    *pte = page2pa(pp) | perm | PTE_P;

    // Success
    return 0;
}

/*
 * Return the page mapped at virtual address 'va'.
 * If pte_store is not zero, then we store in it the address
 * of the pte for this page.  This is used by page_remove and
 * can be used to verify page permissions for syscall arguments,
 * but should not be used by most callers.
 *
 * Return NULL if there is no page mapped at va.
 *
 * Hint: the TA solution uses pgdir_walk and pa2page.
 */
struct page_info *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
    /* Fill this function in */
    panic_if_null("page_lookup: pgdir is NULL!\n", pgdir);

    // Get the pt entry of the va:
    pte_t * pte = pgdir_walk(pgdir, va, 0);

    // TODO: pte_store part of this func!!!
    // ERROR CHECKING: ensure present isn't set, etc

    // if pte_store not 0, set pte's value:
    if (pte_store){
        *pte_store = pte;
    }

    if (!pte){
        return NULL;
    } else {
        return pa2page(PTE_ADDR(*pte));
    }
}


/*
 * Unmaps the physical page at virtual address 'va'.
 * If there is no physical page at that address, silently does nothing.
 *
 * Details:
 *   - The ref count on the physical page should decrement.
 *   - The physical page should be freed if the refcount reaches 0.
 *   - The pg table entry corresponding to 'va' should be set to 0.
 *     (if such a PTE exists)
 *   - The TLB must be invalidated if you remove an entry from
 *     the page table.
 *
 * Hint: The TA solution is implemented using page_lookup,
 *  tlb_invalidate, and page_decref.
 */
void page_remove(pde_t *pgdir, void *va)
{
    panic_if_null("page_remove: PAGE TABLE DIRECTORY NULL\n", (void *)pgdir);

    pte_t *pte;
    struct page_info * pp = page_lookup(pgdir, va, 0);

    if(!pp){
        return;
    }
    if(pp->pp_ref <= 0){
        panic("page_remove: PAGE REF COUNT ALREADY 0\n");
    }
    // decrement the ref count
    pp->pp_ref--;

    // if ref count is 0 free the page
    if(pp->pp_ref == 0)
        page_free(pp);

    // set to zero the pte value
    pte = pgdir_walk(pgdir, va, 0);
    if(pte){
        *pte = 0;
    }

    // invalidate the tlb entry
    tlb_invalidate(pgdir, va);
}

/*
 * Invalidate a TLB entry, but only if the page tables being
 * edited are the ones currently in use by the processor.
 */
void tlb_invalidate(pde_t *pgdir, void *va)
{
    /* Flush the entry only if we're modifying the current address space.
     * For now, there is only one address space, so always invalidate. */
    panic_if_null("pgdir_walk: PAGE TABLE DIRECTORY NULL\n", (void *)pgdir);
    invlpg(va);
}

/***************************************************************
 * Checking functions.
 ***************************************************************/

/*
 * Check that the pages on the page_free_list are reasonable.
 */
static void check_page_free_list(bool only_low_memory)
{
    struct page_info *pp;
    unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
    int nfree_basemem = 0, nfree_extmem = 0;
    char *first_free_page;

    if (!page_free_list)
        panic("'page_free_list' is a null pointer!");

    if (only_low_memory) {
        /* Move pages with lower addresses first in the free list, since
         * entry_pgdir does not map all pages. */
        struct page_info *pp1, *pp2;
        struct page_info **tp[2] = { &pp1, &pp2 };
        for (pp = page_free_list; pp; pp = pp->pp_link) {
            int pagetype = PDX(page2pa(pp)) >= pdx_limit;
            *tp[pagetype] = pp;
            tp[pagetype] = &pp->pp_link;
        }
        *tp[1] = 0;
        *tp[0] = pp2;
        page_free_list = pp1;
    }

    /* if there's a page that shouldn't be on the free list,
     * try to make sure it eventually causes trouble. */
    for (pp = page_free_list; pp; pp = pp->pp_link)
        if (PDX(page2pa(pp)) < pdx_limit)
            memset(page2kva(pp), 0x97, 128);

    first_free_page = (char *) boot_alloc(0);
    for (pp = page_free_list; pp; pp = pp->pp_link) {
        /* check that we didn't corrupt the free list itself */
        assert(pp >= pages);
        assert(pp < pages + npages);
        assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);

        /* check a few pages that shouldn't be on the free list */
        assert(page2pa(pp) != 0);
        assert(page2pa(pp) != IOPHYSMEM);
        assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
        assert(page2pa(pp) != EXTPHYSMEM);
        assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);

        if (page2pa(pp) < EXTPHYSMEM)
            ++nfree_basemem;
        else
            ++nfree_extmem;
    }

    assert(nfree_basemem > 0);
    assert(nfree_extmem > 0);
}

/*
 * Check the physical page allocator (page_alloc(), page_free(),
 * and page_init()).
 */
static void check_page_alloc(void)
{
    struct page_info *pp, *pp0, *pp1, *pp2;
    struct page_info *php0, *php1, *php2;
    int nfree, total_free;
    struct page_info *fl;
    char *c;
    int i;

    if (!pages)
        panic("'pages' is a null pointer!");

    /* check number of free pages */
    for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
        ++nfree;
    total_free = nfree;

    /* should be able to allocate three pages */
    pp0 = pp1 = pp2 = 0;
    assert((pp0 = page_alloc(0)));
    assert((pp1 = page_alloc(0)));
    assert((pp2 = page_alloc(0)));

    assert(pp0);
    assert(pp1 && pp1 != pp0);
    assert(pp2 && pp2 != pp1 && pp2 != pp0);
    assert(page2pa(pp0) < npages*PGSIZE);
    assert(page2pa(pp1) < npages*PGSIZE);
    assert(page2pa(pp2) < npages*PGSIZE);

    /* temporarily steal the rest of the free pages.
     *
     * Lab 1 Bonus:
     * For the bonus, if you go for a different design for the page allocator,
     * then do update here suitably to simulate a no-free-memory situation */
    fl = page_free_list;
    page_free_list = 0;

    /* should be no free memory */
    assert(!page_alloc(0));

    /* free and re-allocate? */
    page_free(pp0);
    page_free(pp1);
    page_free(pp2);
    pp0 = pp1 = pp2 = 0;
    assert((pp0 = page_alloc(0)));
    assert((pp1 = page_alloc(0)));
    assert((pp2 = page_alloc(0)));
    assert(pp0);
    assert(pp1 && pp1 != pp0);
    assert(pp2 && pp2 != pp1 && pp2 != pp0);
    assert(!page_alloc(0));

    /* test flags */
    memset(page2kva(pp0), 1, PGSIZE);
    page_free(pp0);
    assert((pp = page_alloc(ALLOC_ZERO)));
    assert(pp && pp0 == pp);
    c = page2kva(pp);
    for (i = 0; i < PGSIZE; i++)
        assert(c[i] == 0);

    /* give free list back */
    page_free_list = fl;

    /* free the pages we took */
    page_free(pp0);
    page_free(pp1);
    page_free(pp2);

    /* number of free pages should be the same */
    for (pp = page_free_list; pp; pp = pp->pp_link)
        --nfree;
    assert(nfree == 0);

    cprintf("[4K] check_page_alloc() succeeded!\n");
   
    /* test allocation of huge page */
    pp0 = pp1 = php0 = 0;
    assert((pp0 = page_alloc(0)));
    assert((php0 = page_alloc(ALLOC_HUGE)));
    assert((pp1 = page_alloc(0)));
    assert(pp0);
    assert(php0 && php0 != pp0);
    assert(pp1 && pp1 != php0 && pp1 != pp0);
    assert(0 == (page2pa(php0) % (1024*PGSIZE)));
    if (page2pa(pp1) > page2pa(php0)) {
        assert(page2pa(pp1) - page2pa(php0) >= 1024*PGSIZE);
    }

    /* free and reallocate 2 huge pages */
    page_free(php0);
    page_free(pp0);
    page_free(pp1);
    php0 = php1 = pp0 = pp1 = 0;
    assert((php0 = page_alloc(ALLOC_HUGE)));
    assert((php1 = page_alloc(ALLOC_HUGE)));

    /* Is the inter-huge-page difference right? */
    if (page2pa(php1) > page2pa(php0)) {
        assert(page2pa(php1) - page2pa(php0) >= 1024*PGSIZE);
    } else {
        assert(page2pa(php0) - page2pa(php1) >= 1024*PGSIZE);
    }

    /* free the huge pages we took */
    page_free(php0);
    page_free(php1);

    /* number of free pages should be the same */
    nfree = total_free;
    for (pp = page_free_list; pp; pp = pp->pp_link)
        --nfree;
    assert(nfree == 0);

    cprintf("[4M] check_page_alloc() succeeded!\n");
}

/*
 * Checks that the kernel part of virtual address space
 * has been setup roughly correctly (by mem_init()).
 *
 * This function doesn't test every corner case,
 * but it is a pretty good sanity check.
 */
static void check_kern_pgdir(void)
{
    uint32_t i, n;
    pde_t *pgdir;

    pgdir = kern_pgdir;

    /* check pages array */
    n = ROUNDUP(npages*sizeof(struct page_info), PGSIZE);
    for (i = 0; i < n; i += PGSIZE)
        assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);


    /* check phys mem */
    for (i = 0; i < npages * PGSIZE; i += PGSIZE)
        assert(check_va2pa(pgdir, KERNBASE + i) == i);

    /* check kernel stack */
    for (i = 0; i < KSTKSIZE; i += PGSIZE)
        assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
    assert(check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~0);

    /* check PDE permissions */
    for (i = 0; i < NPDENTRIES; i++) {
        switch (i) {
        case PDX(UVPT):
        case PDX(KSTACKTOP-1):
        case PDX(UPAGES):
            assert(pgdir[i] & PTE_P);
            break;
        default:
            if (i >= PDX(KERNBASE)) {
                assert(pgdir[i] & PTE_P);
                assert(pgdir[i] & PTE_W);
            } else
                assert(pgdir[i] == 0);
            break;
        }
    }
    cprintf("check_kern_pgdir() succeeded!\n");
}

/*
 * This function returns the physical address of the page containing 'va',
 * defined by the page directory 'pgdir'.  The hardware normally performs
 * this functionality for us!  We define our own version to help check
 * the check_kern_pgdir() function; it shouldn't be used elsewhere.
 */
static physaddr_t check_va2pa(pde_t *pgdir, uintptr_t va)
{
    pte_t *p;

    pgdir = &pgdir[PDX(va)];
    if (!(*pgdir & PTE_P))
        return ~0;
    p = (pte_t*) KADDR(PTE_ADDR(*pgdir));
    if (!(p[PTX(va)] & PTE_P))
        return ~0;
    return PTE_ADDR(p[PTX(va)]);
}


/* Check page_insert, page_remove, &c */
static void check_page(void)
{
    struct page_info *pp, *pp0, *pp1, *pp2;
    struct page_info *fl;
    pte_t *ptep, *ptep1;
    void *va;
    int i;
    extern pde_t entry_pgdir[];

    /* should be able to allocate three pages */
    pp0 = pp1 = pp2 = 0;
    assert((pp0 = page_alloc(0)));
    assert((pp1 = page_alloc(0)));
    assert((pp2 = page_alloc(0)));

    assert(pp0);
    assert(pp1 && pp1 != pp0);
    assert(pp2 && pp2 != pp1 && pp2 != pp0);

    /* temporarily steal the rest of the free pages.
     *
     * Lab 1 Bonus:
     * For the bonus, if you had chosen a different design for
     * the page allocator, then do update here suitably to
     * simulate a no-free-memory situation */
    fl = page_free_list;
    page_free_list = 0;

    /* should be no free memory */
    assert(!page_alloc(0));

    /* there is no page allocated at address 0 */
    assert(page_lookup(kern_pgdir, (void *) 0x0, &ptep) == NULL);
    /* there is no free memory, so we can't allocate a page table */
    assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0);

    /* free pp0 and try again: pp0 should be used for page table */
    page_free(pp0);
    assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) == 0);
    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
    assert(check_va2pa(kern_pgdir, 0x0) == page2pa(pp1));
    assert(pp1->pp_ref == 1);
    assert(pp0->pp_ref == 1);

    /* should be able to map pp2 at PGSIZE because pp0 is already allocated for page table */
    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
    assert(pp2->pp_ref == 1);

    /* should be no free memory */
    assert(!page_alloc(0));

    /* should be able to map pp2 at PGSIZE because it's already there */
    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
    assert(pp2->pp_ref == 1);
    /* pp2 should NOT be on the free list
     * could happen in ref counts are handled sloppily in page_insert */
    assert(!page_alloc(0));

    /* check that pgdir_walk returns a pointer to the pte */
    ptep = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));
    assert(pgdir_walk(kern_pgdir, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));

    /* should be able to change permissions too. */
    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W|PTE_U) == 0);
    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
    assert(pp2->pp_ref == 1);
    assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U);
    assert(kern_pgdir[0] & PTE_U);

    /* should be able to remap with fewer permissions */
    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
    assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_W);
    assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));

    /* Should not be able to map at PTSIZE because need free page for page
     * table. */

    assert(page_insert(kern_pgdir, pp0, (void*) PTSIZE, PTE_W) < 0);
    /* insert pp1 at PGSIZE (replacing pp2) */
    assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W) == 0);
    assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));

    /* should have pp1 at both 0 and PGSIZE, pp2 nowhere, ... */
    assert(check_va2pa(kern_pgdir, 0) == page2pa(pp1));
    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
    /* ... and ref counts should reflect this */
    assert(pp1->pp_ref == 2);
    assert(pp2->pp_ref == 0);

    /* pp2 should be returned by page_alloc */
    assert((pp = page_alloc(0)) && pp == pp2);

    /* unmapping pp1 at 0 should keep pp1 at PGSIZE */
    page_remove(kern_pgdir, 0x0);
    assert(check_va2pa(kern_pgdir, 0x0) == ~0);
    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
    assert(pp1->pp_ref == 1);
    assert(pp2->pp_ref == 0);

    /* test re-inserting pp1 at PGSIZE */
    assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0);
    assert(pp1->pp_ref);
    assert(pp1->pp_link == NULL);

    /* unmapping pp1 at PGSIZE should free it */
    page_remove(kern_pgdir, (void*) PGSIZE);
    assert(check_va2pa(kern_pgdir, 0x0) == ~0);
    assert(check_va2pa(kern_pgdir, PGSIZE) == ~0);
    assert(pp1->pp_ref == 0);
    assert(pp2->pp_ref == 0);

    /* so it should be returned by page_alloc */
    assert((pp = page_alloc(0)) && pp == pp1);

    /* should be no free memory */
    assert(!page_alloc(0));

    /* forcibly take pp0 back */
    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
    kern_pgdir[0] = 0;
    assert(pp0->pp_ref == 1);
    pp0->pp_ref = 0;

    /* check pointer arithmetic in pgdir_walk */
    page_free(pp0);
    va = (void*)(PGSIZE * NPDENTRIES + PGSIZE);
    ptep = pgdir_walk(kern_pgdir, va, 1);
    ptep1 = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));
    assert(ptep == ptep1 + PTX(va));
    kern_pgdir[PDX(va)] = 0;
    pp0->pp_ref = 0;

    /* check that new page tables get cleared */
    memset(page2kva(pp0), 0xFF, PGSIZE);
    page_free(pp0);
    pgdir_walk(kern_pgdir, 0x0, 1);
    ptep = (pte_t *) page2kva(pp0);
    for(i=0; i<NPTENTRIES; i++)
        assert((ptep[i] & PTE_P) == 0);
    kern_pgdir[0] = 0;
    pp0->pp_ref = 0;

    /* give free list back */
    page_free_list = fl;

    /* free the pages we took */
    page_free(pp0);
    page_free(pp1);
    page_free(pp2);

    cprintf("check_page() succeeded!\n");
}

/* Check page_insert, page_remove, &c, with an installed kern_pgdir */
static void check_page_installed_pgdir(void)
{
    struct page_info *pp, *pp0, *pp1, *pp2;
    struct page_info *fl;
    pte_t *ptep, *ptep1;
    uintptr_t va;
    int i;

    /* check that we can read and write installed pages */
    pp1 = pp2 = 0;
    assert((pp0 = page_alloc(0)));
    assert((pp1 = page_alloc(0)));
    assert((pp2 = page_alloc(0)));
    page_free(pp0);
    memset(page2kva(pp1), 1, PGSIZE);
    memset(page2kva(pp2), 2, PGSIZE);
    page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W);
    assert(pp1->pp_ref == 1);
    assert(*(uint32_t *)PGSIZE == 0x01010101U);
    page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W);
    assert(*(uint32_t *)PGSIZE == 0x02020202U);
    assert(pp2->pp_ref == 1);
    assert(pp1->pp_ref == 0);
    *(uint32_t *)PGSIZE = 0x03030303U;
    assert(*(uint32_t *)page2kva(pp2) == 0x03030303U);
    page_remove(kern_pgdir, (void*) PGSIZE);
    assert(pp2->pp_ref == 0);

    /* forcibly take pp0 back */
    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
    kern_pgdir[0] = 0;
    assert(pp0->pp_ref == 1);
    pp0->pp_ref = 0;

    /* free the pages we took */
    page_free(pp0);

    cprintf("check_page_installed_pgdir() succeeded!\n");
}

/* Check pgdir_walk() for huge page support */
static void check_page_hugepages(void)
{
    struct page_info *php0;
    assert(php0 = page_alloc(ALLOC_HUGE));
    assert(page_insert(kern_pgdir, php0, (void *)(1024*PGSIZE), PTE_W | PTE_PS) == 0);
    assert(php0->pp_ref == 1);
    memset(page2kva(php0), 1, PGSIZE);
    assert(*(uint32_t *)(1024*PGSIZE) == 0x01010101U);
    /* Access the second 4K-page within the huge page */
    memset(page2kva(php0+1), 2, PGSIZE);
    assert(*(uint32_t *)(1025*PGSIZE) == 0x02020202U);
    /* Writing to the last 4K-page within the huge page works? */
    *(uint32_t *)(2*1024*PGSIZE - 42) = 0x42424242U;
    assert(*(uint32_t *)(2*1024*PGSIZE - 42) == 0x42424242U);

    /* Are the underlying frames consecutive? */
    memset(page2kva(php0+1021), 0x37, PGSIZE);
    memset(page2kva(php0+1022), 0x38, PGSIZE);
    assert(*(uint32_t *)((1024+1021)*PGSIZE) == 0x37373737U);
    assert(*(uint32_t *)((1024+1022)*PGSIZE) == 0x38383838U);
    cprintf("3\n");
    /* Check pgdir_walk for the page and the PSE bit */
    pte_t *p_pte1, *p_pte2;
    p_pte1 = pgdir_walk(kern_pgdir, (void*)(1024*PGSIZE), 0);
    assert(NULL != p_pte1);
    assert(*p_pte1 & PTE_PS);
    p_pte2 = pgdir_walk(kern_pgdir, (void*)(1025*PGSIZE), 0);
    assert(NULL != p_pte2);
    assert(p_pte1 == p_pte2);
    /* check page_remove() on the huge page */
    page_remove(kern_pgdir, (void*) (1024*PGSIZE));
    assert(php0->pp_ref == 0);
    assert((php0+1022)->pp_ref == 0);
    /* check CREATE_HUGE flag */
    p_pte1 = pgdir_walk(kern_pgdir, (void*)(1024*PGSIZE), CREATE_HUGE);
    assert(NULL != p_pte1);
    assert(php0 = page_alloc(ALLOC_HUGE));
    assert(page_insert(kern_pgdir, php0, (void *)(2*1024*PGSIZE), PTE_W | PTE_PS) == 0);
    page_remove(kern_pgdir, (void*) (2*1024*PGSIZE));
    assert(php0->pp_ref == 0);

    cprintf("check_page_hugepages() succeeded!\n");
}
